#ifndef i8080_h
#define i8080_h


#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>


#define ADDR_SPACE_SZ 0x10000
#define BEGIN_ADDR 0x100

/*
 *
 * Bit masks for the condition bits.
 *
 *
 * The format of the flag byte is:
 *
 * Bit index (0 is the lowest-order bit)        Value           Role
 * 0                                            C               State of the Carry bit
 * 1                                            1               Always 1
 * 2                                            P               State of the Parity bit
 * 3                                            0               Always 0
 * 4                                            AC              State of the Auxiliary Carry bit
 * 5                                            0               Always 0
 * 6                                            Z               State of the Zero bit
 * 7                                            S               State of the Sign bit
 *
 *
 * Mask for the Carry bit.
 *
 * i8080 ALPM: "The Carry bit is set and reset by certain data operations, and
 * its status can be directly tested by a program. The operations which affect
 * the Carry bit are addition, subtraction, rorate, and logical operations."
 *
 * Stored in bit 0.
 */
#define F_CY 0x01

/*
 * Mask for the Parity bit.
 *
 * i8080 ALPM: "Byte 'parity' is checked after certain operations. The number
 * of 1 bits in a byte are counted, and if the total is odd, 'odd' parity is
 * flaggged; if the total is even, 'even' parity is flagged.
 *      The Parity bit is set to 1 for even parity, and is reset to 0 for odd
 * parity.
 *
 * Stored in bit 2.
 */
#define F_P 0x04

/*
 * Mask for the Auxiliary Carry bit.
 *
 * i8080 ALPM: "The Auxiliary Carry bit indicates carry out of bit 3. The state
 * of the Auxiliary Carry bit cannot be directly tested by a program instruction
 * and is present only to enable one instruction (DAA) to perform its function."
 *
 * Stored in bit 4.
 */
#define F_AC 0x10

/*
 * Mask for the Zero bit.
 *
 * i8080 ALPM: "This condition bit is set if the result generated by the
 * execution of certain instructions is zero. The Zero bit is reset if the
 * result is not zero.
 *      A result that has a carry but a zero answer byte, will also set the
 * Zero bit.
 *
 * Stored in bit 6.
 */
#define F_Z 0x40

/*
 * Mask for the Sign bit.
 *
 * i8080 ALPM: "[...] under Two's Complement Representation, it is possible to
 * treat a byte of data as having the numerical range -128 to +127. In this
 * case, by convention, the 7 bit will always represent the sign of the number;
 * that is, if the 7 bit is 1, the number is in the range -128 to -1. If the bit
 * is 0, the number is in the range 0 to +127.
 *      At the conclusion of certain instructions, the Sign bit will be set to
 * the condition of te most significant bit of the answer (bit 7).
 *
 * Stored in bit 7.
 */
#define F_S 0x80

#if defined(__has_builtin)
#if __has_builtin(__builtin_parity)
        static inline bool parity(uint8_t x) { return !__builtin_parity((unsigned)x); }
#define PARITY_DEFINED 1
#endif
#endif


/* Container for the five condition bits. */
typedef uint8_t flag_t;

typedef uint8_t opcode;

typedef struct {
        /* From the Intel 8080 Assembly Language Programming Manual (i8080 ALPM):
         *
         * "A program will be stored in memory as a sequence of bits which represent
         * the instructions of the program [...] The memory address of the next instruction
         * to be executed is held in the program counter. Just becore each instruction is
         * executed, the program counter is advanced to the address of the next sequential
         * instruction. Program execution proceeds sequentially unless a transfer-of-control
         * instruction (jump, call, or return) is executed, which causes the program counter
         * to be set to a specified address. Execution then continues sequentially from this
         * new address in memory."
         *
         */

        // 8-bit general-purpose registers, arranged in pairs.
        uint8_t B, C;
        uint8_t D, E;
        uint8_t H, L;
        // The accumulator register. Used for storing intermediate results by the ALU.
        uint8_t A; 

        // Program counter
        uint16_t PC;
        // Stack pointer
        uint16_t SP;

        // The flag bits
        flag_t F;

        // The Interrupt Enable flip-flop
        bool INTE;

        // The halted state flip-flop
        bool halted;

        int int_pending;

        // Memory. 65_536 bytes of memory available.
        uint8_t mem[ADDR_SPACE_SZ];
} i8080;


#ifndef PARITY_DEFINED
        static inline bool
        parity(uint8_t x)
        {
                static const uint8_t even[16] = { 1,0,0,1,0,1,1,0, 0,1,1,0,1,0,0,1 };
                x ^= x >> 4;
                return even[x & 0x0F];
        }
#endif


static inline void
flag_set(i8080 *cpu, flag_t mask)
{
        cpu->F |= mask;
}

static inline void
flag_clear(i8080 *cpu, flag_t mask)
{
        cpu->F &= ~mask;
}

static inline void
flag_toggle(i8080 *cpu, flag_t mask)
{
        cpu->F ^= mask;
}

static inline bool
flag_get(const i8080 *cpu, flag_t mask)
{
        return cpu->F & mask;
}

static inline void
flag_write(i8080 *cpu, uint8_t mask, uint8_t cond)
{
        cpu->F = (cpu->F & ~mask) | cond;
}

static void
reset_flags(i8080 *cpu)
{
        cpu->F = 0;
        cpu->F |= 0x02;
}

static inline uint8_t
stack_pop(i8080 *cpu)
{
        return cpu->mem[cpu->SP++];
}


static inline void dispatch(i8080 *cpu, opcode op);
void emulate(i8080 *cpu);
void init(i8080 *cpu, const char *path);
static void load(i8080 *cpu, const char *path);


#endif